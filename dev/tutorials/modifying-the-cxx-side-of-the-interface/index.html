<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modifying the C++ side of the interface · DACE.jl</title><meta name="title" content="Modifying the C++ side of the interface · DACE.jl"/><meta property="og:title" content="Modifying the C++ side of the interface · DACE.jl"/><meta property="twitter:title" content="Modifying the C++ side of the interface · DACE.jl"/><meta name="description" content="Documentation for DACE.jl."/><meta property="og:description" content="Documentation for DACE.jl."/><meta property="twitter:description" content="Documentation for DACE.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DACE.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../setting-up-your-development-environment/">Setting up your development environment</a></li><li class="is-active"><a class="tocitem" href>Modifying the C++ side of the interface</a><ul class="internal"><li><a class="tocitem" href="#Switch-to-your-dace-directory"><span>Switch to your dace directory</span></a></li><li><a class="tocitem" href="#Defining-the-Julia-module"><span>Defining the Julia module</span></a></li><li><a class="tocitem" href="#Adding-DA-static-methods"><span>Adding DA static methods</span></a></li><li><a class="tocitem" href="#Adding-the-DA-type"><span>Adding the DA type</span></a></li><li><a class="tocitem" href="#Adding-methods-to-the-DA-type"><span>Adding methods to the DA type</span></a></li><li><a class="tocitem" href="#Adding-methods-to-another-module"><span>Adding methods to another module</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../generated/sine/">Sine function</a></li><li><a class="tocitem" href="../../generated/polynomial_inversion/">Polynomial inversion</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Modifying the C++ side of the interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Modifying the C++ side of the interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/a-ev/DACE.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/a-ev/DACE.jl/blob/main/docs/src/tutorials/modifying-the-cxx-side-of-the-interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Modifying-the-C-side-of-the-interface"><a class="docs-heading-anchor" href="#Modifying-the-C-side-of-the-interface">Modifying the C++ side of the interface</a><a id="Modifying-the-C-side-of-the-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-the-C-side-of-the-interface" title="Permalink"></a></h1><p>This tutorial will give a brief explanation of the C++ side of the DACE Julia interface, which will hopefully allow you to make changes and add new functionality to the interface.</p><p>Note that there are two sides to the interface:</p><ul><li>the C++ side of the interface, which exists in the DACE C++ source code</li><li>the Julia side of the interface, which exists in the DACE.jl Julia package</li></ul><p>The Julia interface on the C++ side is created using <a href="https://github.com/JuliaInterop/CxxWrap.jl">CxxWrap.jl</a>, which is documented in the <em>README.md</em> file in their git repo.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is assumed that you have successfully followed the tutorial to <a href="../setting-up-your-development-environment/">set up your development environment</a>. It is also assumed that you will refer to the <a href="https://github.com/JuliaInterop/CxxWrap.jl">CxxWrap.jl documentation</a>.</p></div></div><h2 id="Switch-to-your-dace-directory"><a class="docs-heading-anchor" href="#Switch-to-your-dace-directory">Switch to your dace directory</a><a id="Switch-to-your-dace-directory-1"></a><a class="docs-heading-anchor-permalink" href="#Switch-to-your-dace-directory" title="Permalink"></a></h2><p>Switch to your <em>dace</em> directory that you set up during the <a href="../setting-up-your-development-environment/">setting up your development environment tutorial</a></p><pre><code class="nohighlight hljs">cd /path/to/dace</code></pre><p>Inside that directory you should see a sub-directory called <em>build</em> which is where we have compiled the DACE C++ library. You should also see an <em>interfaces</em> directory. Switch into the <em>interfaces/julia</em> directory</p><pre><code class="nohighlight hljs">cd interfaces/julia</code></pre><p>Inside this directory you will see the file <em>dace_julia.cxx</em>, which contains the source code for the Julia interface.</p><h2 id="Defining-the-Julia-module"><a class="docs-heading-anchor" href="#Defining-the-Julia-module">Defining the Julia module</a><a id="Defining-the-Julia-module-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Julia-module" title="Permalink"></a></h2><p>In <em>dace_julia.cxx</em> you will see</p><pre><code class="language-cxx hljs">JLCXX_MODULE define_julia_module(jlcxx::module&amp; mod) {
    // code omitted here
}</code></pre><p>All the methods and types defined within the <code>define_julia_module</code> function using <code>mod</code> will belong to the generated Julia module when we load it in the <em>DACE.jl</em> package.</p><p>Refer also to the <a href="https://github.com/JuliaInterop/CxxWrap.jl?tab=readme-ov-file#module-entry-point">CxxWrap.jl module entry point documentation</a>.</p><h2 id="Adding-DA-static-methods"><a class="docs-heading-anchor" href="#Adding-DA-static-methods">Adding DA static methods</a><a id="Adding-DA-static-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-DA-static-methods" title="Permalink"></a></h2><p>In the first section of the <code>define_julia_module</code> function we add some <code>DA</code> static methods:</p><pre><code class="language-cxx hljs">// add DA static methods separately
mod.method(&quot;init&quot;, [](const unsigned int ord, const unsigned int nvar) {
        DA::init(ord, nvar);
    });
mod.method(&quot;getMaxOrder&quot;, []()-&gt;int64_t { return DA::getMaxOrder(); });
mod.method(&quot;getMaxVariables&quot;, []()-&gt;int64_t { return DA::getMaxVariables(); });
mod.method(&quot;getMaxMonomials&quot;, []()-&gt;int64_t { return DA::getMaxMonomials(); });
mod.method(&quot;setEps&quot;, [](const double eps) { return DA::setEps(eps); });
mod.method(&quot;getEps&quot;, []() { return DA::getEps(); });
mod.method(&quot;getEpsMac&quot;, []() { return DA::getEpsMac(); });
mod.method(&quot;setTO&quot;, [](const unsigned int ot) { return DA::setTO(ot); });
mod.method(&quot;getTO&quot;, []() { return DA::getTO(); });
mod.method(&quot;pushTO&quot;, [](const unsigned int ot) { DA::pushTO(ot); });
mod.method(&quot;popTO&quot;, []() { DA::popTO(); });</code></pre><p>Here <code>mod</code> is the Julia module and when we call <code>mod.method</code> we are adding a new method (function) to the Julia module.</p><p>Take the <code>init</code> function for example:</p><pre><code class="language-cxx hljs">mod.method(&quot;init&quot;, [](const unsigned int ord, const unsigned int nvar) { DA::init(ord, nvar); });</code></pre><p>The first argument to <code>mod.method</code> is the name of the function as it should appear in the Julia module that we are creating, in this case the new function will be named <code>init</code>.</p><p>The second argument to <code>mod.method</code> is the C++ function that should be called when some calls the <code>init</code> function in the Julia module that we are creating. In this case we are using a C++ <a href="https://en.cppreference.com/w/cpp/language/lambda">lambda function</a> but you could pass a normal C++ function also. The lambda function, denoted by the <code>[]</code>, takes two arguments, <code>ord</code> and <code>nvar</code> (the order and number of variables) and runs the code within the curly braces, <code>DA::init(ord, nvar);</code>, i.e. it calls the DA static method <code>init</code> with the two arguments that were passed in from Julia.</p><p>You can return values back to Julia and CxxWrap.jl can automatically infer the type of the return value, such as:</p><pre><code class="language-cxx hljs">mod.method(&quot;getEps&quot;, []() { return DA::getEps(); });</code></pre><p>is a lambda function (<code>[]</code>) that takes no arguments (<code>()</code>) and returns the epsilon value <code>return DA::getEps();</code> and automatically converts the C++ return type to a Julia type.</p><p>It is also possible to specify the return type, which we have done in some cases to avoid compiler warnings, e.g. we specify the return type of <code>getMaxOrder</code> to be of type <code>int64_t</code> here:</p><pre><code class="language-cxx hljs">mod.method(&quot;getMaxOrder&quot;, []()-&gt;int64_t { return DA::getMaxOrder(); });</code></pre><h2 id="Adding-the-DA-type"><a class="docs-heading-anchor" href="#Adding-the-DA-type">Adding the DA type</a><a id="Adding-the-DA-type-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-the-DA-type" title="Permalink"></a></h2><p>Refer to the CxxWrap.jl documentation about <a href="https://github.com/JuliaInterop/CxxWrap.jl?tab=readme-ov-file#exposing-classes">exposing C++ classes</a>.</p><p>C++ classes are exposed to Julia using <code>mod.add_type&lt;&gt;()</code>, for example we expose the <code>DA</code> class with:</p><pre><code class="language-cxx hljs">// add the DA object
mod.add_type&lt;DA&gt;(&quot;DA&quot;, jlcxx::julia_type(&quot;Real&quot;, &quot;Base&quot;))</code></pre><p>Here the template parameter, <code>&lt;DA&gt;</code>, is the C++ class to expose, the first argument <code>&quot;DA&quot;</code> is the name of corresponding type to create in Julia and the optional second argument can be used to specify which type the new type should inherit from. In this case the Julia <code>DA</code> type will inherit from the Julia <code>Real</code> type (<code>jlcxx::julia_type(&quot;Real&quot;, &quot;Base&quot;)</code>).</p><p>Different constructors for the new type can be added, here we define three constructors:</p><pre><code class="language-cxx hljs">mod.add_type&lt;DA&gt;(&quot;DA&quot;, jlcxx::julia_type(&quot;Real&quot;, &quot;Base&quot;))
    .constructor&lt;&gt;()
    .constructor&lt;const double&gt;()
    .constructor&lt;const int, const double&gt;()</code></pre><ul><li><code>.constructor&lt;&gt;()</code>: the default constructor that takes no arguments</li><li><code>.constructor&lt;const double</code>(): the <code>DA</code> constructor that takes a single double as an argument</li><li><code>.constructor&lt;const int, const double&gt;()</code>: the <code>DA</code> constructor that takes and integer and double</li></ul><p>CxxWrap will automatically call the correct C++ constructor that matches the arguments in the template parameters.</p><h2 id="Adding-methods-to-the-DA-type"><a class="docs-heading-anchor" href="#Adding-methods-to-the-DA-type">Adding methods to the DA type</a><a id="Adding-methods-to-the-DA-type-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-methods-to-the-DA-type" title="Permalink"></a></h2><p>Methods can be chained onto the <code>mod.add_type</code> or defined separately. An example of chaining a method is:</p><pre><code class="language-cxx hljs">mod.add_type&lt;DA&gt;(&quot;DA&quot;, jlcxx::julia_type(&quot;Real&quot;, &quot;Base&quot;))
    .constructor&lt;&gt;()
    .constructor&lt;const double&gt;()
    .constructor&lt;const int, const double&gt;()
    .method(&quot;toString&quot;, &amp;DA::toString);</code></pre><p>After the three constructors we also add <code>DA::toString</code> as a method in the Julia module named <code>toString</code>. CxxWrap will automatically make the first argument of the method a <code>DA</code> type because we have chained it onto the <code>mod.add_type&lt;DA&gt;()</code>.</p><p>We can also directly add <code>DA</code> methods using:</p><pre><code class="language-cxx hljs">mod.method(&quot;gamma&quot;, [](const DA&amp; da) { return da.GammaFunction(); });</code></pre><p>which creates a <code>&quot;gamma&quot;</code> Julia method that is called with a <code>DA</code> as the first argument and returns the result of calling the C++ <code>DA</code> member function <code>da.GammaFunction()</code>.</p><h2 id="Adding-methods-to-another-module"><a class="docs-heading-anchor" href="#Adding-methods-to-another-module">Adding methods to another module</a><a id="Adding-methods-to-another-module-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-methods-to-another-module" title="Permalink"></a></h2><p>So far, whenever we use <code>mod.method</code> or <code>mod.add_type</code> it adds the methods and types to our new Julia module. We can add methods to another module, such as the Julia Base module, using</p><pre><code class="language-cxx hljs">mod.set_override_module(jl_base_module);

// all methods here are added to the base module
mod.method(&quot;+&quot;, [](const DA&amp; da1, const DA&amp; da2) { return da1 + da2; });
mod.method(&quot;+&quot;, [](const DA&amp; da, const double c) { return da + c; });
mod.method(&quot;+&quot;, [](const double c, const DA&amp; da) { return c + da; });

// until we call this, then subsequent calls to mod.method will add methods to our module again
mod.unset_override_module();</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../setting-up-your-development-environment/">« Setting up your development environment</a><a class="docs-footer-nextpage" href="../../generated/sine/">Sine function »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Wednesday 17 April 2024 21:50">Wednesday 17 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
